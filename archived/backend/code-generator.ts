/**
 * Code Generator for Playwright Assistant
 * Generates test code from recorded browser interactions
 */

// =============================================================================
// Types and Interfaces
// =============================================================================

export type ActionType =
    | 'click'
    | 'dblclick'
    | 'type'
    | 'fill'
    | 'scroll'
    | 'navigate'
    | 'select'
    | 'check'
    | 'uncheck'
    | 'hover'
    | 'press'
    | 'screenshot'
    | 'waitForSelector'
    | 'waitForNavigation'
    | 'frame'
    | 'popup';

export interface ElementInfo {
    tagName: string;
    id?: string;
    className?: string;
    name?: string;
    type?: string;
    role?: string;
    ariaLabel?: string;
    placeholder?: string;
    text?: string;
    testId?: string;
    href?: string;
    value?: string;
    xpath?: string;
    cssSelector?: string;
    attributes?: Record<string, string>;
}

export interface RecordedAction {
    id: string;
    type: ActionType;
    timestamp: number;
    url?: string;
    element?: ElementInfo;
    x?: number;
    y?: number;
    deltaX?: number;
    deltaY?: number;
    text?: string;
    key?: string;
    modifiers?: string[];
    frameUrl?: string;
    popupUrl?: string;
    screenshot?: string;
}

export interface RecordedSession {
    id: string;
    name: string;
    startTime: number;
    endTime?: number;
    startUrl: string;
    actions: RecordedAction[];
    metadata?: {
        browserName?: string;
        viewport?: { width: number; height: number };
        userAgent?: string;
    };
}

export type CodeFormat = 'playwright' | 'puppeteer' | 'selenium';
export type CodeLanguage = 'javascript' | 'typescript' | 'python';

export interface CodeGeneratorOptions {
    format: CodeFormat;
    language: CodeLanguage;
    includeComments: boolean;
    includeWaits: boolean;
    useLocators: boolean;  // Use Playwright locators (getByRole, etc.)
    groupActions: boolean;
    addAssertions: boolean;
    testName?: string;
    indentSize: number;
}

export interface GeneratedCode {
    code: string;
    language: CodeLanguage;
    format: CodeFormat;
    filename: string;
}

// =============================================================================
// Selector Generation
// =============================================================================

class SelectorGenerator {
    /**
     * Generate the best selector for an element
     * Priority: testId > role + name > id > aria-label > placeholder > text > CSS
     */
    static generateSelector(element: ElementInfo, options: CodeGeneratorOptions): string {
        if (options.useLocators && options.format === 'playwright') {
            return this.generatePlaywrightLocator(element);
        }
        return this.generateCssSelector(element);
    }

    static generatePlaywrightLocator(element: ElementInfo): string {
        // 1. data-testid is most stable
        if (element.testId) {
            return `getByTestId('${this.escapeString(element.testId)}')`;
        }

        // 2. Role-based selectors with accessible name
        if (element.role) {
            const roleName = element.ariaLabel || element.text;
            if (roleName) {
                return `getByRole('${element.role}', { name: '${this.escapeString(roleName)}' })`;
            }
            return `getByRole('${element.role}')`;
        }

        // 3. Infer role from tag
        const inferredRole = this.inferRole(element);
        if (inferredRole) {
            const name = element.ariaLabel || element.text || element.value;
            if (name) {
                return `getByRole('${inferredRole}', { name: '${this.escapeString(name)}' })`;
            }
        }

        // 4. Label for form elements
        if (element.ariaLabel) {
            return `getByLabel('${this.escapeString(element.ariaLabel)}')`;
        }

        // 5. Placeholder for inputs
        if (element.placeholder) {
            return `getByPlaceholder('${this.escapeString(element.placeholder)}')`;
        }

        // 6. Text content
        if (element.text && element.text.length < 50) {
            return `getByText('${this.escapeString(element.text)}')`;
        }

        // 7. Fall back to CSS selector
        return `locator('${this.escapeString(this.generateCssSelector(element))}')`;
    }

    static generateCssSelector(element: ElementInfo): string {
        // Prefer data-testid
        if (element.testId) {
            return `[data-testid="${element.testId}"]`;
        }

        // Use ID if stable (not auto-generated)
        if (element.id && !this.isAutoGeneratedId(element.id)) {
            return `#${element.id}`;
        }

        // Use name attribute for form elements
        if (element.name) {
            return `${element.tagName.toLowerCase()}[name="${element.name}"]`;
        }

        // Use aria-label
        if (element.ariaLabel) {
            return `[aria-label="${element.ariaLabel}"]`;
        }

        // Use type for inputs
        if (element.tagName.toLowerCase() === 'input' && element.type) {
            if (element.placeholder) {
                return `input[type="${element.type}"][placeholder="${element.placeholder}"]`;
            }
            return `input[type="${element.type}"]`;
        }

        // Use provided CSS selector or xpath
        if (element.cssSelector) {
            return element.cssSelector;
        }

        // Construct from class and tag
        if (element.className) {
            const classes = element.className.split(' ')
                .filter(c => c && !this.isAutoGeneratedClass(c))
                .slice(0, 2)
                .join('.');
            if (classes) {
                return `${element.tagName.toLowerCase()}.${classes}`;
            }
        }

        // Last resort: tag name
        return element.tagName.toLowerCase();
    }

    static inferRole(element: ElementInfo): string | null {
        const tag = element.tagName.toLowerCase();
        const type = element.type?.toLowerCase();

        const roleMap: Record<string, string> = {
            'button': 'button',
            'a': 'link',
            'input:checkbox': 'checkbox',
            'input:radio': 'radio',
            'input:text': 'textbox',
            'input:email': 'textbox',
            'input:password': 'textbox',
            'input:search': 'searchbox',
            'input:submit': 'button',
            'textarea': 'textbox',
            'select': 'combobox',
            'img': 'img',
            'h1': 'heading',
            'h2': 'heading',
            'h3': 'heading',
            'h4': 'heading',
            'h5': 'heading',
            'h6': 'heading',
            'nav': 'navigation',
            'main': 'main',
            'article': 'article',
            'aside': 'complementary',
            'footer': 'contentinfo',
            'header': 'banner',
            'dialog': 'dialog',
            'table': 'table',
            'tr': 'row',
            'th': 'columnheader',
            'td': 'cell',
            'ul': 'list',
            'ol': 'list',
            'li': 'listitem',
        };

        const key = type ? `${tag}:${type}` : tag;
        return roleMap[key] || roleMap[tag] || null;
    }

    static isAutoGeneratedId(id: string): boolean {
        // Common patterns for auto-generated IDs
        const patterns = [
            /^[a-f0-9]{8,}$/i,
            /^react-/,
            /^ember\d+/,
            /^:r[0-9a-z]+:/,
            /^\d+$/,
            /_\d+$/,
        ];
        return patterns.some(p => p.test(id));
    }

    static isAutoGeneratedClass(className: string): boolean {
        const patterns = [
            /^css-[a-z0-9]+$/i,
            /^sc-[a-z]+$/i,  // styled-components
            /^_[a-zA-Z0-9]+_[a-z0-9]+$/,  // CSS modules
            /^[a-z]+_[a-z]+__[a-zA-Z0-9]+$/,  // BEM with hash
        ];
        return patterns.some(p => p.test(className));
    }

    static escapeString(str: string): string {
        return str.replace(/'/g, "\\'").replace(/\n/g, '\\n');
    }
}

// =============================================================================
// Code Generators
// =============================================================================

abstract class BaseCodeGenerator {
    protected options: CodeGeneratorOptions;
    protected indent: string;

    constructor(options: CodeGeneratorOptions) {
        this.options = options;
        this.indent = ' '.repeat(options.indentSize);
    }

    abstract generate(session: RecordedSession): GeneratedCode;
    abstract generateFromActions(actions: RecordedAction[], startUrl?: string): GeneratedCode;

    protected generateComment(text: string): string {
        if (!this.options.includeComments) return '';

        switch (this.options.language) {
            case 'python':
                return `# ${text}\n`;
            default:
                return `// ${text}\n`;
        }
    }

    protected getFilename(): string {
        const name = this.options.testName || 'recorded-test';
        const ext = this.getFileExtension();
        return `${name}.${ext}`;
    }

    protected getFileExtension(): string {
        switch (this.options.language) {
            case 'typescript':
                return 'ts';
            case 'python':
                return 'py';
            default:
                return 'js';
        }
    }

    protected getSelector(element: ElementInfo | undefined): string {
        if (!element) return "''";
        return SelectorGenerator.generateSelector(element, this.options);
    }

    protected describeAction(action: RecordedAction): string {
        switch (action.type) {
            case 'click':
                return `Click on ${this.describeElement(action.element)}`;
            case 'dblclick':
                return `Double-click on ${this.describeElement(action.element)}`;
            case 'type':
            case 'fill':
                return `Fill "${action.text}" into ${this.describeElement(action.element)}`;
            case 'navigate':
                return `Navigate to ${action.url}`;
            case 'scroll':
                return `Scroll ${action.deltaY && action.deltaY > 0 ? 'down' : 'up'}`;
            case 'select':
                return `Select "${action.text}" in ${this.describeElement(action.element)}`;
            case 'check':
                return `Check ${this.describeElement(action.element)}`;
            case 'uncheck':
                return `Uncheck ${this.describeElement(action.element)}`;
            case 'hover':
                return `Hover over ${this.describeElement(action.element)}`;
            case 'press':
                return `Press ${action.key}`;
            case 'waitForSelector':
                return `Wait for ${this.describeElement(action.element)}`;
            case 'waitForNavigation':
                return `Wait for navigation`;
            case 'frame':
                return `Switch to frame: ${action.frameUrl}`;
            case 'popup':
                return `Handle popup: ${action.popupUrl}`;
            default:
                return `Perform ${action.type} action`;
        }
    }

    protected describeElement(element: ElementInfo | undefined): string {
        if (!element) return 'element';

        if (element.testId) return `[data-testid="${element.testId}"]`;
        if (element.ariaLabel) return `"${element.ariaLabel}"`;
        if (element.text && element.text.length < 30) return `"${element.text}"`;
        if (element.placeholder) return `placeholder "${element.placeholder}"`;
        if (element.id) return `#${element.id}`;
        if (element.role) return `${element.role}`;
        return element.tagName.toLowerCase();
    }
}

// =============================================================================
// Playwright Code Generator
// =============================================================================

class PlaywrightCodeGenerator extends BaseCodeGenerator {
    generate(session: RecordedSession): GeneratedCode {
        return this.generateFromActions(session.actions, session.startUrl);
    }

    generateFromActions(actions: RecordedAction[], startUrl?: string): GeneratedCode {
        const isTs = this.options.language === 'typescript';
        const isPy = this.options.language === 'python';

        let code = '';

        if (isPy) {
            code = this.generatePythonPlaywright(actions, startUrl);
        } else {
            code = this.generateJsPlaywright(actions, startUrl, isTs);
        }

        return {
            code,
            language: this.options.language,
            format: 'playwright',
            filename: this.getFilename()
        };
    }

    private generatePythonPlaywright(actions: RecordedAction[], startUrl?: string): string {
        let code = `import re
from playwright.sync_api import Page, expect

def test_recorded_session(page: Page):
`;
        const i = this.indent;

        if (startUrl) {
            code += `${i}${this.generateComment(`Navigate to the starting URL`)}`;
            code += `${i}page.goto("${startUrl}")\n\n`;
        }

        const groupedActions = this.options.groupActions ? this.groupRelatedActions(actions) : actions.map(a => [a]);

        for (const group of groupedActions) {
            for (const action of group) {
                code += this.generatePythonAction(action, i);
            }
            code += '\n';
        }

        return code;
    }

    private generateJsPlaywright(actions: RecordedAction[], startUrl: string | undefined, isTs: boolean): string {
        const testType = isTs ? ': Page' : '';

        let code = `import { test, expect } from '@playwright/test';

test('recorded session', async ({ page }${testType}) => {
`;
        const i = this.indent;

        if (startUrl) {
            code += `${i}${this.generateComment(`Navigate to the starting URL`)}`;
            code += `${i}await page.goto('${startUrl}');\n\n`;
        }

        const groupedActions = this.options.groupActions ? this.groupRelatedActions(actions) : actions.map(a => [a]);

        for (const group of groupedActions) {
            for (const action of group) {
                code += this.generateJsAction(action, i);
            }
            code += '\n';
        }

        code += '});\n';
        return code;
    }

    private generateJsAction(action: RecordedAction, indent: string): string {
        let code = '';
        const comment = this.generateComment(this.describeAction(action));

        if (comment) {
            code += `${indent}${comment}`;
        }

        switch (action.type) {
            case 'navigate':
                code += `${indent}await page.goto('${action.url}');\n`;
                if (this.options.addAssertions) {
                    code += `${indent}await expect(page).toHaveURL(/${this.urlToRegex(action.url || '')}/);\n`;
                }
                break;

            case 'click':
                if (this.options.useLocators && action.element) {
                    const locator = SelectorGenerator.generatePlaywrightLocator(action.element);
                    code += `${indent}await page.${locator}.click();\n`;
                } else {
                    code += `${indent}await page.click('${this.getCssSelector(action.element)}');\n`;
                }
                break;

            case 'dblclick':
                if (this.options.useLocators && action.element) {
                    const locator = SelectorGenerator.generatePlaywrightLocator(action.element);
                    code += `${indent}await page.${locator}.dblclick();\n`;
                } else {
                    code += `${indent}await page.dblclick('${this.getCssSelector(action.element)}');\n`;
                }
                break;

            case 'fill':
            case 'type':
                if (this.options.useLocators && action.element) {
                    const locator = SelectorGenerator.generatePlaywrightLocator(action.element);
                    code += `${indent}await page.${locator}.fill('${SelectorGenerator.escapeString(action.text || '')}');\n`;
                } else {
                    code += `${indent}await page.fill('${this.getCssSelector(action.element)}', '${SelectorGenerator.escapeString(action.text || '')}');\n`;
                }
                break;

            case 'select':
                if (this.options.useLocators && action.element) {
                    const locator = SelectorGenerator.generatePlaywrightLocator(action.element);
                    code += `${indent}await page.${locator}.selectOption('${SelectorGenerator.escapeString(action.text || '')}');\n`;
                } else {
                    code += `${indent}await page.selectOption('${this.getCssSelector(action.element)}', '${SelectorGenerator.escapeString(action.text || '')}');\n`;
                }
                break;

            case 'check':
                if (this.options.useLocators && action.element) {
                    const locator = SelectorGenerator.generatePlaywrightLocator(action.element);
                    code += `${indent}await page.${locator}.check();\n`;
                } else {
                    code += `${indent}await page.check('${this.getCssSelector(action.element)}');\n`;
                }
                break;

            case 'uncheck':
                if (this.options.useLocators && action.element) {
                    const locator = SelectorGenerator.generatePlaywrightLocator(action.element);
                    code += `${indent}await page.${locator}.uncheck();\n`;
                } else {
                    code += `${indent}await page.uncheck('${this.getCssSelector(action.element)}');\n`;
                }
                break;

            case 'hover':
                if (this.options.useLocators && action.element) {
                    const locator = SelectorGenerator.generatePlaywrightLocator(action.element);
                    code += `${indent}await page.${locator}.hover();\n`;
                } else {
                    code += `${indent}await page.hover('${this.getCssSelector(action.element)}');\n`;
                }
                break;

            case 'press':
                code += `${indent}await page.keyboard.press('${action.key}');\n`;
                break;

            case 'scroll':
                code += `${indent}await page.mouse.wheel(${action.deltaX || 0}, ${action.deltaY || 0});\n`;
                break;

            case 'waitForSelector':
                if (this.options.useLocators && action.element) {
                    const locator = SelectorGenerator.generatePlaywrightLocator(action.element);
                    code += `${indent}await page.${locator}.waitFor();\n`;
                } else {
                    code += `${indent}await page.waitForSelector('${this.getCssSelector(action.element)}');\n`;
                }
                break;

            case 'waitForNavigation':
                code += `${indent}await page.waitForNavigation();\n`;
                break;

            case 'frame':
                code += `${indent}const frame = page.frameLocator('${action.frameUrl}');\n`;
                break;

            case 'popup':
                code += `${indent}const [popup] = await Promise.all([\n`;
                code += `${indent}${this.indent}page.waitForEvent('popup'),\n`;
                code += `${indent}${this.indent}// Trigger popup action here\n`;
                code += `${indent}]);\n`;
                break;
        }

        return code;
    }

    private generatePythonAction(action: RecordedAction, indent: string): string {
        let code = '';
        const comment = this.generateComment(this.describeAction(action));

        if (comment) {
            code += `${indent}${comment}`;
        }

        switch (action.type) {
            case 'navigate':
                code += `${indent}page.goto("${action.url}")\n`;
                if (this.options.addAssertions) {
                    code += `${indent}expect(page).to_have_url(re.compile(r"${this.urlToRegex(action.url || '')}"))\n`;
                }
                break;

            case 'click':
                if (this.options.useLocators && action.element) {
                    const locator = this.pythonLocator(action.element);
                    code += `${indent}page.${locator}.click()\n`;
                } else {
                    code += `${indent}page.click("${this.getCssSelector(action.element)}")\n`;
                }
                break;

            case 'dblclick':
                if (this.options.useLocators && action.element) {
                    const locator = this.pythonLocator(action.element);
                    code += `${indent}page.${locator}.dblclick()\n`;
                } else {
                    code += `${indent}page.dblclick("${this.getCssSelector(action.element)}")\n`;
                }
                break;

            case 'fill':
            case 'type':
                if (this.options.useLocators && action.element) {
                    const locator = this.pythonLocator(action.element);
                    code += `${indent}page.${locator}.fill("${SelectorGenerator.escapeString(action.text || '').replace(/"/g, '\\"')}")\n`;
                } else {
                    code += `${indent}page.fill("${this.getCssSelector(action.element)}", "${SelectorGenerator.escapeString(action.text || '').replace(/"/g, '\\"')}")\n`;
                }
                break;

            case 'select':
                if (this.options.useLocators && action.element) {
                    const locator = this.pythonLocator(action.element);
                    code += `${indent}page.${locator}.select_option("${SelectorGenerator.escapeString(action.text || '').replace(/"/g, '\\"')}")\n`;
                } else {
                    code += `${indent}page.select_option("${this.getCssSelector(action.element)}", "${SelectorGenerator.escapeString(action.text || '').replace(/"/g, '\\"')}")\n`;
                }
                break;

            case 'check':
                if (this.options.useLocators && action.element) {
                    const locator = this.pythonLocator(action.element);
                    code += `${indent}page.${locator}.check()\n`;
                } else {
                    code += `${indent}page.check("${this.getCssSelector(action.element)}")\n`;
                }
                break;

            case 'uncheck':
                if (this.options.useLocators && action.element) {
                    const locator = this.pythonLocator(action.element);
                    code += `${indent}page.${locator}.uncheck()\n`;
                } else {
                    code += `${indent}page.uncheck("${this.getCssSelector(action.element)}")\n`;
                }
                break;

            case 'hover':
                if (this.options.useLocators && action.element) {
                    const locator = this.pythonLocator(action.element);
                    code += `${indent}page.${locator}.hover()\n`;
                } else {
                    code += `${indent}page.hover("${this.getCssSelector(action.element)}")\n`;
                }
                break;

            case 'press':
                code += `${indent}page.keyboard.press("${action.key}")\n`;
                break;

            case 'scroll':
                code += `${indent}page.mouse.wheel(${action.deltaX || 0}, ${action.deltaY || 0})\n`;
                break;

            case 'waitForSelector':
                if (this.options.useLocators && action.element) {
                    const locator = this.pythonLocator(action.element);
                    code += `${indent}page.${locator}.wait_for()\n`;
                } else {
                    code += `${indent}page.wait_for_selector("${this.getCssSelector(action.element)}")\n`;
                }
                break;

            case 'waitForNavigation':
                code += `${indent}page.wait_for_navigation()\n`;
                break;

            case 'frame':
                code += `${indent}frame = page.frame_locator("${action.frameUrl}")\n`;
                break;

            case 'popup':
                code += `${indent}with page.expect_popup() as popup_info:\n`;
                code += `${indent}${this.indent}pass  # Trigger popup action here\n`;
                code += `${indent}popup = popup_info.value\n`;
                break;
        }

        return code;
    }

    private pythonLocator(element: ElementInfo): string {
        const locator = SelectorGenerator.generatePlaywrightLocator(element);
        // Convert JS style to Python style
        return locator
            .replace(/'/g, '"')
            .replace(/getByTestId/g, 'get_by_test_id')
            .replace(/getByRole/g, 'get_by_role')
            .replace(/getByLabel/g, 'get_by_label')
            .replace(/getByPlaceholder/g, 'get_by_placeholder')
            .replace(/getByText/g, 'get_by_text')
            .replace(/{ name:/g, 'name=');
    }

    private getCssSelector(element: ElementInfo | undefined): string {
        if (!element) return '';
        return SelectorGenerator.generateCssSelector(element);
    }

    private urlToRegex(url: string): string {
        try {
            const parsed = new URL(url);
            return parsed.pathname.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
        } catch {
            return url.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
        }
    }

    private groupRelatedActions(actions: RecordedAction[]): RecordedAction[][] {
        const groups: RecordedAction[][] = [];
        let currentGroup: RecordedAction[] = [];
        let lastType: string | null = null;
        let lastTime = 0;

        for (const action of actions) {
            const timeDiff = action.timestamp - lastTime;
            const isRelated =
                // Group rapid successive clicks on same element
                (action.type === 'click' && lastType === 'click' && timeDiff < 500) ||
                // Group type/fill actions
                (action.type === 'type' && lastType === 'type' && timeDiff < 100) ||
                // Keep navigation separate
                action.type !== 'navigate' && lastType !== 'navigate';

            if (!isRelated && currentGroup.length > 0) {
                groups.push(currentGroup);
                currentGroup = [];
            }

            currentGroup.push(action);
            lastType = action.type;
            lastTime = action.timestamp;
        }

        if (currentGroup.length > 0) {
            groups.push(currentGroup);
        }

        return groups;
    }
}

// =============================================================================
// Puppeteer Code Generator
// =============================================================================

class PuppeteerCodeGenerator extends BaseCodeGenerator {
    generate(session: RecordedSession): GeneratedCode {
        return this.generateFromActions(session.actions, session.startUrl);
    }

    generateFromActions(actions: RecordedAction[], startUrl?: string): GeneratedCode {
        const isTs = this.options.language === 'typescript';

        let code = '';

        if (this.options.language === 'python') {
            code = this.generatePythonPuppeteer(actions, startUrl);
        } else {
            code = this.generateJsPuppeteer(actions, startUrl, isTs);
        }

        return {
            code,
            language: this.options.language,
            format: 'puppeteer',
            filename: this.getFilename()
        };
    }

    private generateJsPuppeteer(actions: RecordedAction[], startUrl: string | undefined, isTs: boolean): string {
        const browserType = isTs ? ': Browser' : '';
        const pageType = isTs ? ': Page' : '';

        let code = isTs
            ? `import puppeteer, { Browser, Page } from 'puppeteer';\n\n`
            : `const puppeteer = require('puppeteer');\n\n`;

        code += `(async () => {
    const browser${browserType} = await puppeteer.launch({ headless: false });
    const page${pageType} = await browser.newPage();

`;
        const i = this.indent;

        if (startUrl) {
            code += `${i}${this.generateComment(`Navigate to the starting URL`)}`;
            code += `${i}await page.goto('${startUrl}');\n\n`;
        }

        for (const action of actions) {
            code += this.generateJsAction(action, i);
        }

        code += `
    // Uncomment to close browser when done
    // await browser.close();
})();
`;
        return code;
    }

    private generatePythonPuppeteer(actions: RecordedAction[], startUrl?: string): string {
        let code = `import asyncio
from pyppeteer import launch

async def main():
    browser = await launch(headless=False)
    page = await browser.newPage()

`;
        const i = this.indent;

        if (startUrl) {
            code += `${i}${this.generateComment(`Navigate to the starting URL`)}`;
            code += `${i}await page.goto("${startUrl}")\n\n`;
        }

        for (const action of actions) {
            code += this.generatePythonAction(action, i);
        }

        code += `
    # Uncomment to close browser when done
    # await browser.close()

asyncio.get_event_loop().run_until_complete(main())
`;
        return code;
    }

    private generateJsAction(action: RecordedAction, indent: string): string {
        let code = '';
        const comment = this.generateComment(this.describeAction(action));

        if (comment) {
            code += `${indent}${comment}`;
        }

        const selector = this.getCssSelector(action.element);

        switch (action.type) {
            case 'navigate':
                code += `${indent}await page.goto('${action.url}');\n`;
                break;

            case 'click':
                if (this.options.includeWaits) {
                    code += `${indent}await page.waitForSelector('${selector}');\n`;
                }
                code += `${indent}await page.click('${selector}');\n`;
                break;

            case 'dblclick':
                if (this.options.includeWaits) {
                    code += `${indent}await page.waitForSelector('${selector}');\n`;
                }
                code += `${indent}await page.click('${selector}', { clickCount: 2 });\n`;
                break;

            case 'fill':
            case 'type':
                if (this.options.includeWaits) {
                    code += `${indent}await page.waitForSelector('${selector}');\n`;
                }
                code += `${indent}await page.type('${selector}', '${SelectorGenerator.escapeString(action.text || '')}');\n`;
                break;

            case 'select':
                if (this.options.includeWaits) {
                    code += `${indent}await page.waitForSelector('${selector}');\n`;
                }
                code += `${indent}await page.select('${selector}', '${SelectorGenerator.escapeString(action.text || '')}');\n`;
                break;

            case 'hover':
                if (this.options.includeWaits) {
                    code += `${indent}await page.waitForSelector('${selector}');\n`;
                }
                code += `${indent}await page.hover('${selector}');\n`;
                break;

            case 'press':
                code += `${indent}await page.keyboard.press('${action.key}');\n`;
                break;

            case 'scroll':
                code += `${indent}await page.evaluate(() => window.scrollBy(${action.deltaX || 0}, ${action.deltaY || 0}));\n`;
                break;

            case 'waitForSelector':
                code += `${indent}await page.waitForSelector('${selector}');\n`;
                break;

            case 'waitForNavigation':
                code += `${indent}await page.waitForNavigation();\n`;
                break;

            case 'frame':
                code += `${indent}const frame = await page.frames().find(f => f.url().includes('${action.frameUrl}'));\n`;
                break;
        }

        code += '\n';
        return code;
    }

    private generatePythonAction(action: RecordedAction, indent: string): string {
        let code = '';
        const comment = this.generateComment(this.describeAction(action));

        if (comment) {
            code += `${indent}${comment}`;
        }

        const selector = this.getCssSelector(action.element);

        switch (action.type) {
            case 'navigate':
                code += `${indent}await page.goto("${action.url}")\n`;
                break;

            case 'click':
                if (this.options.includeWaits) {
                    code += `${indent}await page.waitForSelector("${selector}")\n`;
                }
                code += `${indent}await page.click("${selector}")\n`;
                break;

            case 'dblclick':
                if (this.options.includeWaits) {
                    code += `${indent}await page.waitForSelector("${selector}")\n`;
                }
                code += `${indent}await page.click("${selector}", {"clickCount": 2})\n`;
                break;

            case 'fill':
            case 'type':
                if (this.options.includeWaits) {
                    code += `${indent}await page.waitForSelector("${selector}")\n`;
                }
                code += `${indent}await page.type("${selector}", "${SelectorGenerator.escapeString(action.text || '').replace(/"/g, '\\"')}")\n`;
                break;

            case 'select':
                if (this.options.includeWaits) {
                    code += `${indent}await page.waitForSelector("${selector}")\n`;
                }
                code += `${indent}await page.select("${selector}", "${SelectorGenerator.escapeString(action.text || '').replace(/"/g, '\\"')}")\n`;
                break;

            case 'hover':
                if (this.options.includeWaits) {
                    code += `${indent}await page.waitForSelector("${selector}")\n`;
                }
                code += `${indent}await page.hover("${selector}")\n`;
                break;

            case 'press':
                code += `${indent}await page.keyboard.press("${action.key}")\n`;
                break;

            case 'scroll':
                code += `${indent}await page.evaluate("window.scrollBy(${action.deltaX || 0}, ${action.deltaY || 0})")\n`;
                break;

            case 'waitForSelector':
                code += `${indent}await page.waitForSelector("${selector}")\n`;
                break;

            case 'waitForNavigation':
                code += `${indent}await page.waitForNavigation()\n`;
                break;
        }

        code += '\n';
        return code;
    }

    private getCssSelector(element: ElementInfo | undefined): string {
        if (!element) return '';
        return SelectorGenerator.generateCssSelector(element);
    }
}

// =============================================================================
// Selenium Code Generator
// =============================================================================

class SeleniumCodeGenerator extends BaseCodeGenerator {
    generate(session: RecordedSession): GeneratedCode {
        return this.generateFromActions(session.actions, session.startUrl);
    }

    generateFromActions(actions: RecordedAction[], startUrl?: string): GeneratedCode {
        let code = '';

        if (this.options.language === 'python') {
            code = this.generatePythonSelenium(actions, startUrl);
        } else {
            code = this.generateJsSelenium(actions, startUrl, this.options.language === 'typescript');
        }

        return {
            code,
            language: this.options.language,
            format: 'selenium',
            filename: this.getFilename()
        };
    }

    private generateJsSelenium(actions: RecordedAction[], startUrl: string | undefined, isTs: boolean): string {
        let code = isTs
            ? `import { Builder, By, until, WebDriver } from 'selenium-webdriver';

(async () => {
    const driver: WebDriver = await new Builder().forBrowser('chrome').build();

`
            : `const { Builder, By, until } = require('selenium-webdriver');

(async () => {
    const driver = await new Builder().forBrowser('chrome').build();

`;
        const i = this.indent;

        if (startUrl) {
            code += `${i}${this.generateComment(`Navigate to the starting URL`)}`;
            code += `${i}await driver.get('${startUrl}');\n\n`;
        }

        for (const action of actions) {
            code += this.generateJsAction(action, i);
        }

        code += `
    // Uncomment to close browser when done
    // await driver.quit();
})();
`;
        return code;
    }

    private generatePythonSelenium(actions: RecordedAction[], startUrl?: string): string {
        let code = `from selenium import webdriver
from selenium.webdriver.common.by import By
from selenium.webdriver.common.keys import Keys
from selenium.webdriver.support.ui import WebDriverWait
from selenium.webdriver.support import expected_conditions as EC

driver = webdriver.Chrome()

`;
        const i = '';  // Python uses no extra indent at top level

        if (startUrl) {
            code += `${this.generateComment(`Navigate to the starting URL`)}`;
            code += `driver.get("${startUrl}")\n\n`;
        }

        for (const action of actions) {
            code += this.generatePythonAction(action, i);
        }

        code += `
# Uncomment to close browser when done
# driver.quit()
`;
        return code;
    }

    private generateJsAction(action: RecordedAction, indent: string): string {
        let code = '';
        const comment = this.generateComment(this.describeAction(action));

        if (comment) {
            code += `${indent}${comment}`;
        }

        const locator = this.getSeleniumLocator(action.element, 'js');

        switch (action.type) {
            case 'navigate':
                code += `${indent}await driver.get('${action.url}');\n`;
                break;

            case 'click':
                if (this.options.includeWaits) {
                    code += `${indent}await driver.wait(until.elementLocated(${locator}), 10000);\n`;
                }
                code += `${indent}await driver.findElement(${locator}).click();\n`;
                break;

            case 'dblclick':
                if (this.options.includeWaits) {
                    code += `${indent}await driver.wait(until.elementLocated(${locator}), 10000);\n`;
                }
                code += `${indent}const element = await driver.findElement(${locator});\n`;
                code += `${indent}await driver.actions().doubleClick(element).perform();\n`;
                break;

            case 'fill':
            case 'type':
                if (this.options.includeWaits) {
                    code += `${indent}await driver.wait(until.elementLocated(${locator}), 10000);\n`;
                }
                code += `${indent}await driver.findElement(${locator}).sendKeys('${SelectorGenerator.escapeString(action.text || '')}');\n`;
                break;

            case 'select':
                if (this.options.includeWaits) {
                    code += `${indent}await driver.wait(until.elementLocated(${locator}), 10000);\n`;
                }
                code += `${indent}const select = await driver.findElement(${locator});\n`;
                code += `${indent}await select.findElement(By.xpath(\`//option[text()='${action.text}']\`)).click();\n`;
                break;

            case 'hover':
                if (this.options.includeWaits) {
                    code += `${indent}await driver.wait(until.elementLocated(${locator}), 10000);\n`;
                }
                code += `${indent}const hoverElement = await driver.findElement(${locator});\n`;
                code += `${indent}await driver.actions().move({ origin: hoverElement }).perform();\n`;
                break;

            case 'press':
                code += `${indent}await driver.actions().sendKeys('${action.key}').perform();\n`;
                break;

            case 'scroll':
                code += `${indent}await driver.executeScript('window.scrollBy(${action.deltaX || 0}, ${action.deltaY || 0})');\n`;
                break;

            case 'waitForSelector':
                code += `${indent}await driver.wait(until.elementLocated(${locator}), 10000);\n`;
                break;

            case 'frame':
                code += `${indent}await driver.switchTo().frame(driver.findElement(By.css('iframe[src*="${action.frameUrl}"]')));\n`;
                break;
        }

        code += '\n';
        return code;
    }

    private generatePythonAction(action: RecordedAction, indent: string): string {
        let code = '';
        const comment = this.generateComment(this.describeAction(action));

        if (comment) {
            code += `${indent}${comment}`;
        }

        const locator = this.getSeleniumLocator(action.element, 'python');

        switch (action.type) {
            case 'navigate':
                code += `${indent}driver.get("${action.url}")\n`;
                break;

            case 'click':
                if (this.options.includeWaits) {
                    code += `${indent}WebDriverWait(driver, 10).until(EC.presence_of_element_located(${locator}))\n`;
                }
                code += `${indent}driver.find_element(${locator}).click()\n`;
                break;

            case 'dblclick':
                if (this.options.includeWaits) {
                    code += `${indent}WebDriverWait(driver, 10).until(EC.presence_of_element_located(${locator}))\n`;
                }
                code += `${indent}from selenium.webdriver.common.action_chains import ActionChains\n`;
                code += `${indent}element = driver.find_element(${locator})\n`;
                code += `${indent}ActionChains(driver).double_click(element).perform()\n`;
                break;

            case 'fill':
            case 'type':
                if (this.options.includeWaits) {
                    code += `${indent}WebDriverWait(driver, 10).until(EC.presence_of_element_located(${locator}))\n`;
                }
                code += `${indent}driver.find_element(${locator}).send_keys("${SelectorGenerator.escapeString(action.text || '').replace(/"/g, '\\"')}")\n`;
                break;

            case 'select':
                if (this.options.includeWaits) {
                    code += `${indent}WebDriverWait(driver, 10).until(EC.presence_of_element_located(${locator}))\n`;
                }
                code += `${indent}from selenium.webdriver.support.ui import Select\n`;
                code += `${indent}select = Select(driver.find_element(${locator}))\n`;
                code += `${indent}select.select_by_visible_text("${action.text}")\n`;
                break;

            case 'hover':
                if (this.options.includeWaits) {
                    code += `${indent}WebDriverWait(driver, 10).until(EC.presence_of_element_located(${locator}))\n`;
                }
                code += `${indent}from selenium.webdriver.common.action_chains import ActionChains\n`;
                code += `${indent}element = driver.find_element(${locator})\n`;
                code += `${indent}ActionChains(driver).move_to_element(element).perform()\n`;
                break;

            case 'press':
                code += `${indent}from selenium.webdriver.common.action_chains import ActionChains\n`;
                code += `${indent}ActionChains(driver).send_keys(Keys.${this.pythonKey(action.key || '')}).perform()\n`;
                break;

            case 'scroll':
                code += `${indent}driver.execute_script("window.scrollBy(${action.deltaX || 0}, ${action.deltaY || 0})")\n`;
                break;

            case 'waitForSelector':
                code += `${indent}WebDriverWait(driver, 10).until(EC.presence_of_element_located(${locator}))\n`;
                break;

            case 'frame':
                code += `${indent}driver.switch_to.frame(driver.find_element(By.CSS_SELECTOR, 'iframe[src*="${action.frameUrl}"]'))\n`;
                break;
        }

        code += '\n';
        return code;
    }

    private getSeleniumLocator(element: ElementInfo | undefined, lang: 'js' | 'python'): string {
        if (!element) return lang === 'js' ? "By.css('')" : "(By.CSS_SELECTOR, '')";

        // Prefer stable selectors
        if (element.testId) {
            return lang === 'js'
                ? `By.css('[data-testid="${element.testId}"]')`
                : `(By.CSS_SELECTOR, '[data-testid="${element.testId}"]')`;
        }

        if (element.id && !SelectorGenerator.isAutoGeneratedId(element.id)) {
            return lang === 'js'
                ? `By.id('${element.id}')`
                : `(By.ID, "${element.id}")`;
        }

        if (element.name) {
            return lang === 'js'
                ? `By.name('${element.name}')`
                : `(By.NAME, "${element.name}")`;
        }

        if (element.xpath) {
            return lang === 'js'
                ? `By.xpath('${element.xpath}')`
                : `(By.XPATH, "${element.xpath}")`;
        }

        const css = SelectorGenerator.generateCssSelector(element);
        return lang === 'js'
            ? `By.css('${css}')`
            : `(By.CSS_SELECTOR, "${css}")`;
    }

    private pythonKey(key: string): string {
        const keyMap: Record<string, string> = {
            'Enter': 'RETURN',
            'Tab': 'TAB',
            'Escape': 'ESCAPE',
            'ArrowUp': 'ARROW_UP',
            'ArrowDown': 'ARROW_DOWN',
            'ArrowLeft': 'ARROW_LEFT',
            'ArrowRight': 'ARROW_RIGHT',
            'Backspace': 'BACKSPACE',
            'Delete': 'DELETE',
            'Home': 'HOME',
            'End': 'END',
            'PageUp': 'PAGE_UP',
            'PageDown': 'PAGE_DOWN',
        };
        return keyMap[key] || key.toUpperCase();
    }
}

// =============================================================================
// Main Code Generator Factory
// =============================================================================

export class CodeGenerator {
    private options: CodeGeneratorOptions;

    constructor(options: Partial<CodeGeneratorOptions> = {}) {
        this.options = {
            format: options.format || 'playwright',
            language: options.language || 'typescript',
            includeComments: options.includeComments ?? true,
            includeWaits: options.includeWaits ?? true,
            useLocators: options.useLocators ?? true,
            groupActions: options.groupActions ?? true,
            addAssertions: options.addAssertions ?? false,
            testName: options.testName,
            indentSize: options.indentSize || 4,
        };
    }

    /**
     * Generate code from a recorded session
     */
    generate(session: RecordedSession): GeneratedCode {
        const generator = this.createGenerator();
        return generator.generate(session);
    }

    /**
     * Generate code from an array of actions
     */
    generateFromActions(actions: RecordedAction[], startUrl?: string): GeneratedCode {
        const generator = this.createGenerator();
        return generator.generateFromActions(actions, startUrl);
    }

    /**
     * Update options
     */
    setOptions(options: Partial<CodeGeneratorOptions>): void {
        this.options = { ...this.options, ...options };
    }

    private createGenerator(): BaseCodeGenerator {
        switch (this.options.format) {
            case 'puppeteer':
                return new PuppeteerCodeGenerator(this.options);
            case 'selenium':
                return new SeleniumCodeGenerator(this.options);
            case 'playwright':
            default:
                return new PlaywrightCodeGenerator(this.options);
        }
    }
}

// =============================================================================
// Recording Session Manager (for integration with relay server)
// =============================================================================

export class RecordingSessionManager {
    private sessions: Map<string, RecordedSession> = new Map();
    private activeSessionId: string | null = null;

    /**
     * Start a new recording session
     */
    startSession(name: string, startUrl: string): RecordedSession {
        const session: RecordedSession = {
            id: this.generateId(),
            name,
            startTime: Date.now(),
            startUrl,
            actions: []
        };
        this.sessions.set(session.id, session);
        this.activeSessionId = session.id;
        return session;
    }

    /**
     * Stop the active recording session
     */
    stopSession(): RecordedSession | null {
        if (!this.activeSessionId) return null;

        const session = this.sessions.get(this.activeSessionId);
        if (session) {
            session.endTime = Date.now();
        }
        this.activeSessionId = null;
        return session || null;
    }

    /**
     * Record an action in the active session
     */
    recordAction(action: Omit<RecordedAction, 'id' | 'timestamp'>): RecordedAction | null {
        if (!this.activeSessionId) return null;

        const session = this.sessions.get(this.activeSessionId);
        if (!session) return null;

        const recordedAction: RecordedAction = {
            ...action,
            id: this.generateId(),
            timestamp: Date.now()
        };

        session.actions.push(recordedAction);
        return recordedAction;
    }

    /**
     * Get a session by ID
     */
    getSession(id: string): RecordedSession | undefined {
        return this.sessions.get(id);
    }

    /**
     * Get all sessions
     */
    getAllSessions(): RecordedSession[] {
        return Array.from(this.sessions.values());
    }

    /**
     * Get the active session
     */
    getActiveSession(): RecordedSession | null {
        if (!this.activeSessionId) return null;
        return this.sessions.get(this.activeSessionId) || null;
    }

    /**
     * Delete a session
     */
    deleteSession(id: string): boolean {
        return this.sessions.delete(id);
    }

    /**
     * Clear all sessions
     */
    clearSessions(): void {
        this.sessions.clear();
        this.activeSessionId = null;
    }

    private generateId(): string {
        return `${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;
    }
}

// Export default instance for convenience
export const codeGenerator = new CodeGenerator();
export const sessionManager = new RecordingSessionManager();
